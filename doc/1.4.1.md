## Что такое compile-time вычисления?

В других языках вы могли встречать константы, которые "как бы константы". В JavaScript можно написать:

```javascript
const PI = Math.PI; // Это вычисляется во время выполнения
```

Rust смотрит на это и качает головой: "Нет, друг. Если ты говоришь 'константа', то это должно быть константой *по-настоящему*."

В Rust константы должны быть вычислены во время компиляции. Это значит, что когда ваша программа уже скомпилирована и готова к запуску, все константы уже имеют свои окончательные значения, "вшитые" прямо в код.

```rust
const PI: f64 = 3.14159265359; // ✅ Отлично! Литерал известен при компиляции
const RADIUS: f64 = 5.0;       // ✅ Тоже хорошо
const AREA: f64 = PI * RADIUS * RADIUS; // ✅ И это тоже работает!
```

*Остановка для размышлений: Заметили, что мы можем использовать одну константу для вычисления другой? Компилятор Rust — настоящий математик, он может выполнять арифметические операции прямо во время компиляции.*

## Что можно, а что нельзя

Давайте поэкспериментируем. Вот что *можно* делать в константах:

```rust
const SECONDS_IN_MINUTE: u32 = 60;
const MINUTES_IN_HOUR: u32 = 60;
const SECONDS_IN_HOUR: u32 = SECONDS_IN_MINUTE * MINUTES_IN_HOUR; // 3600

// Арифметические операции
const DOUBLE_PI: f64 = 3.14159 * 2.0;

// Логические операции
const IS_PRODUCTION: bool = true;
const DEBUG_MODE: bool = !IS_PRODUCTION;

// Работа со строками (но осторожно!)
const GREETING: &str = "Привет, мир!";
```

А вот что *нельзя*:

```rust
use std::time::SystemTime;

// ❌ Это не работает!
// const CURRENT_TIME: SystemTime = SystemTime::now();
//   Функция `now()` вызывается во время выполнения

// ❌ И это тоже не работает!
// const RANDOM_NUMBER: u32 = rand::random();
//   Случайные числа генерируются во время выполнения
```

**Совет на полях:** Думайте о константах как о "застывших во времени" значениях. Если для вычисления значения нужно что-то узнать из внешнего мира (текущее время, случайное число, содержимое файла), то это не может быть константой.

## Типы, которые могут быть константами

Не все типы в Rust могут быть константами. Компилятор должен быть уверен, что он может вычислить значение без обращения к памяти или внешним ресурсам.

### Примитивные типы — наши верные друзья

```rust
const NUMBER: i32 = 42;
const FLOAT: f64 = 3.14;
const CHAR: char = 'Я';
const BOOLEAN: bool = true;
```

### Строки — с оговорками

```rust
const MESSAGE: &str = "Константная строка";
// Но НЕ String! String выделяет память в куче во время выполнения
```

### Массивы фиксированного размера

```rust
const FIBONACCI: [u32; 5] = [1, 1, 2, 3, 5];
const ZEROS: [i32; 100] = [0; 100]; // 100 нулей
```

### Кортежи

```rust
const POINT: (i32, i32) = (10, 20);
const RGB_RED: (u8, u8, u8) = (255, 0, 0);
```

## Функции в константах — const fn

Вот где начинается настоящая магия. Rust позволяет вызывать функции в константах, но только специальные — помеченные как `const fn`:

```rust
const fn square(x: u32) -> u32 {
    x * x
}

const FOUR_SQUARED: u32 = square(4); // 16
const FIVE_SQUARED: u32 = square(5); // 25
```

*Внутренний диалог программиста: "Подожди, это значит, что функция `square` выполняется во время компиляции? Да! Компилятор буквально вычисляет результат и вставляет готовое значение 16 в место `FOUR_SQUARED`."*

## Практический пример: конфигурация приложения

Представьте, что вы создаёте игру. У вас есть настройки, которые никогда не изменятся:

```rust
// Размеры игрового поля
const FIELD_WIDTH: u32 = 800;
const FIELD_HEIGHT: u32 = 600;
const FIELD_AREA: u32 = FIELD_WIDTH * FIELD_HEIGHT;

// Настройки игрока
const PLAYER_SPEED: f32 = 5.0;
const PLAYER_HEALTH: u32 = 100;

// Вычисляемые константы
const DIAGONAL_SPEED: f32 = PLAYER_SPEED * 0.707; // √2/2 ≈ 0.707

// Строковые константы
const GAME_TITLE: &str = "Моя Супер Игра";
const VERSION: &str = "1.0.0";

// Массивы констант
const DIFFICULTY_MULTIPLIERS: [f32; 3] = [0.8, 1.0, 1.5]; // лёгкий, нормальный, сложный
```

**Совет на полях:** Константы — отличный способ избежать "магических чисел" в коде. Вместо загадочного `if health < 25` напишите `if health < CRITICAL_HEALTH_THRESHOLD`, где `CRITICAL_HEALTH_THRESHOLD` — это константа.

## Где объявлять константы

В отличие от переменных, константы можно объявлять в любой области видимости:

```rust
// Глобальная константа (доступна везде в модуле)
const GLOBAL_CONSTANT: i32 = 42;

fn main() {
    // Локальная константа (доступна только в этой функции)
    const LOCAL_CONSTANT: i32 = 24;
    
    println!("Глобальная: {}", GLOBAL_CONSTANT);
    println!("Локальная: {}", LOCAL_CONSTANT);
}
```

## Заключение: константы как гарантия

Константы в Rust — это не просто "переменные, которые не изменяются". Это гарантия того, что значение известно ещё до запуска программы. Это делает ваш код:

- **Быстрее**: нет необходимости вычислять значения во время выполнения
- **Безопаснее**: невозможно случайно изменить константу
- **Понятнее**: читающий код сразу видит, что это неизменяемое значение

В следующий раз, когда вы подумаете "мне нужна переменная, которая не изменяется", спросите себя: "А может, это должна быть константа?" Если значение можно вычислить во время компиляции — смело делайте его константой. Ваш код станет лучше, а компилятор Rust скажет вам спасибо своей молниеносной работой.

---