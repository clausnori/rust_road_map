Вы стоите перед выбором. В левой руке — `const`, в правой — `static`. Оба выглядят похоже, оба обещают постоянство. Но только один из них подходит для вашей задачи.

*"Да в чём разница-то? Оба же неизменяемые!"* — воскликнете вы. 

Ах, если бы всё было так просто...

## Первое впечатление: они почти близнецы

```rust
const MAX_USERS: i32 = 1000;
static MAX_CONNECTIONS: i32 = 1000;

fn main() {
    println!("Пользователей: {}", MAX_USERS);
    println!("Соединений: {}", MAX_CONNECTIONS);
}
```

Код работает одинаково. Но под капотом происходят совершенно разные вещи.

## Разгадка первая: где живут данные?

Представьте библиотеку с двумя типами книг:

**`const` — это книги-призраки.** Они существуют только в каталоге. Когда вы просите конкретную книгу, библиотекарь не идёт за ней на полку — он создаёт копию прямо у вас на глазах.

**`static` — это книги на полке.** Есть конкретное место, конкретная полка, конкретная книга. Все читатели берут одну и ту же физическую книгу.

```rust
const MAGIC_NUMBER: i32 = 42;
static GLOBAL_COUNTER: i32 = 42;

fn use_const() {
    let a = MAGIC_NUMBER;  // Компилятор вставляет 42 прямо сюда
    let b = MAGIC_NUMBER;  // И сюда тоже вставляет 42
    // a и b — независимые копии
}

fn use_static() {
    let a = &GLOBAL_COUNTER;  // Получаем ссылку на одну и ту же переменную
    let b = &GLOBAL_COUNTER;  // И здесь ссылка на ту же самую переменную
    // a и b указывают на одно место в памяти
}
```

> **На полях:** Поэтому вы можете брать ссылки на `static`, но не можете на `const` — нельзя сослаться на то, что существует только в момент компиляции!

## Разгадка вторая: время жизни

```rust
const NAME: &str = "Константа";
static TITLE: &str = "Статическая переменная";

fn get_const_reference() -> &'static str {
    // ❌ Это НЕ скомпилируется!
    // &NAME  // Нет физического адреса для ссылки
    
    "Пришлось вернуть строковый литерал"
}

fn get_static_reference() -> &'static str {
    // ✅ Это работает отлично!
    &TITLE  // Есть конкретный адрес в памяти
}
```

*"Стоп, почему так?"* — недоумеваете вы. Потому что `const` не имеет адреса в памяти во время выполнения. Это просто инструкция компилятору: "вставь это значение везде, где встретишь это имя".

## Разгадка третья: сложные вычисления

```rust
const fn calculate_const() -> i32 {
    10 + 5 * 2
}

// ✅ const может использовать const функции
const RESULT: i32 = calculate_const();

// ✅ static тоже может, но с ограничениями
static STATIC_RESULT: i32 = calculate_const();

fn regular_function() -> i32 {
    42
}

// ❌ Обычные функции нельзя использовать ни в const, ни в static
// const BAD_CONST: i32 = regular_function();
// static BAD_STATIC: i32 = regular_function();
```

## Практический эксперимент: размер программы

```rust
const BUFFER_SIZE: usize = 1024;
static GLOBAL_BUFFER_SIZE: usize = 1024;

fn create_many_buffers() {
    let buf1 = [0u8; BUFFER_SIZE];    // Константа вставляется как 1024
    let buf2 = [0u8; BUFFER_SIZE];    // И здесь тоже как 1024
    let buf3 = [0u8; BUFFER_SIZE];    // И здесь...
    
    // Каждое использование BUFFER_SIZE заменяется на 1024
}

fn use_static_size() {
    println!("Размер: {}", GLOBAL_BUFFER_SIZE);  // Обращение к памяти
    println!("Снова: {}", GLOBAL_BUFFER_SIZE);   // Ещё одно обращение к памяти
}
```

> **Остановка для размышлений:** Если вы используете `const` много раз в коде, компилятор каждый раз вставляет значение. Если значение большое (например, массив), это может увеличить размер программы. `static` — это всегда одно место в памяти.

## Когда использовать const, а когда static?

### Используйте `const` когда:

```rust
// Простые значения, которые никогда не изменятся
const PI: f64 = 3.14159;
const MAX_RETRY_ATTEMPTS: u8 = 3;

// Размеры для массивов
const BUFFER_SIZE: usize = 512;
let buffer = [0u8; BUFFER_SIZE];

// Строковые литералы для сообщений
const ERROR_MESSAGE: &str = "Что-то пошло не так";
```

### Используйте `static` когда:

```rust
// Нужны ссылки на данные
static CONFIG_PATH: &str = "/etc/myapp/config.toml";

fn get_config_path() -> &'static str {
    &CONFIG_PATH  // Можем вернуть ссылку!
}

// Большие данные, которые не хотите дублировать
static LOOKUP_TABLE: [i32; 10000] = [0; 10000];

// Данные, которые могут изменяться (с mut)
static mut GLOBAL_STATE: i32 = 0;
```

## Визуальное сравнение

| Характеристика | `const` | `static` |
|---|---|---|
| **Где живёт** | В коде (inline) | В памяти |
| **Можно взять ссылку** | ❌ Нет | ✅ Да |
| **При множественном использовании** | Копируется | Одно место |
| **Изменяемость** | Никогда | С `mut` и `unsafe` |
| **Время жизни** | Время компиляции | `'static` |

## Маленькая загадка

Что произойдёт с этим кодом?

```rust
const LUCKY_NUMBER: i32 = 7;
static MAGIC_NUMBER: i32 = 7;

fn main() {
    println!("Адрес константы: {:p}", &LUCKY_NUMBER as *const i32);
    println!("Адрес статической: {:p}", &MAGIC_NUMBER as *const i32);
    
    println!("Ещё раз константа: {:p}", &LUCKY_NUMBER as *const i32);
    println!("Ещё раз статическая: {:p}", &MAGIC_NUMBER as *const i32);
}
```

> **Разгадка:** Адреса константы могут отличаться (компилятор может создавать новые копии), а адрес статической переменной всегда один и тот же!

## Практический совет: золотое правило выбора

*Спросите себя: "Нужна ли мне ссылка на это значение?"*

- **Да** → используйте `static`
- **Нет** → используйте `const`

*Всё ещё сомневаетесь?*

*Спросите себя: "Это значение большое и используется много раз?"*

- **Да** → используйте `static` (экономия памяти)
- **Нет** → используйте `const` (простота)

---

*Теперь вы знаете секрет различия между `const` и `static`. В следующий раз,
когда увидите их в коде, вы будете понимать не только что они делают, но и
почему именно этот выбор был сделан программистом.*