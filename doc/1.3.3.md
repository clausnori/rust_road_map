
*Или почему Rust заставляет нас сказать «да, я действительно хочу это изменить»*

---

Представьте себе библиотеку, где книги приклеены к полкам. Странно? Именно так чувствует себя программист, впервые столкнувшийся с переменными в Rust. Попытка изменить значение переменной встречается холодным отказом компилятора:

```rust
fn main() {
    let score = 10;
    score = 15; // Ошибка! Cannot assign twice to immutable variable
}
```

«Что за чепуха?» — думает программист, пришедший из JavaScript или Python. «Это же переменная! Она должна... ну... изменяться!»

Но Rust мыслит иначе. Здесь каждая переменная по умолчанию неизменяема. Это не ошибка дизайна — это философия.

## Неизменяемость как добродетель

*Пауза для размышлений: Когда вы в последний раз случайно изменили переменную в другой части программы и потратили часы на поиск бага?*

В большинстве программ переменные действительно не должны изменяться. Они устанавливаются один раз и используются для чтения. Rust делает это поведение явным:

```rust
fn main() {
    let name = "Алиса";
    let age = 25;
    let city = "Москва";
    
    println!("Меня зовут {}, мне {} лет, живу в {}", name, age, city);
    // Все переменные используются только для чтения — идеально!
}
```

Здесь нет никаких сюрпризов. Значения установлены, используются, и никто их случайно не испортит.

## Когда изменения неизбежны

Но жизнь не статична. Счетчики увеличиваются, пользователи вводят новые данные, игроки набирают очки. Для таких случаев Rust предлагает ключевое слово `mut`:

```rust
fn main() {
    let mut score = 0;
    println!("Начальный счет: {}", score);
    
    score = 10; // Теперь это работает!
    println!("Счет после первого уровня: {}", score);
    
    score = score + 5;
    println!("Финальный счет: {}", score);
}
```

*Совет на полях: Читайте `let mut` как «позволь изменять». Это именно то, что вы говорите компилятору.*

## Диалог с компилятором

Представьте разговор между вами и компилятором Rust:

**Вы:** `let x = 5;`  
**Rust:** «Понял. x равен 5 и никогда не изменится.»

**Вы:** `x = 10;`  
**Rust:** «Стоп! Ты же сказал, что x не будет изменяться. Определись!»

**Вы:** `let mut x = 5;`  
**Rust:** «Ага, теперь ясно. x может изменяться.»

**Вы:** `x = 10;`  
**Rust:** «Отлично, изменяю на 10.»

Этот диалог происходит на этапе компиляции. Никаких сюрпризов во время выполнения программы.

## Практический пример: счетчик посещений

Давайте создадим простой счетчик — классический пример изменяемой переменной:

```rust
fn main() {
    let mut visitors = 0;
    
    println!("Сайт запущен. Посетителей: {}", visitors);
    
    // Пришел первый посетитель
    visitors = visitors + 1;
    println!("Новый посетитель! Всего: {}", visitors);
    
    // Еще несколько посетителей
    visitors = visitors + 3;
    println!("Еще посетители! Всего: {}", visitors);
}
```

*Остановка для размышлений: Попробуйте убрать `mut` из этого примера. Какую ошибку выдаст компилятор? Это поможет лучше понять разницу.*

## Тонкости изменяемости

### Частичная изменяемость

В Rust изменяемость касается самой переменной, а не того, на что она ссылается. Это важное различие:

```rust
fn main() {
    let mut numbers = vec![1, 2, 3];
    numbers.push(4); // Изменяем содержимое вектора
    
    let numbers = vec![1, 2, 3]; // Без mut
    // numbers.push(4); // Ошибка! Нельзя изменить неизменяемую переменную
}
```

### Переопределение vs изменение

Rust различает переопределение переменной (shadowing) и её изменение:

```rust
fn main() {
    let x = 5;
    let x = 10; // Это shadowing — создание новой переменной
    println!("{}", x); // Выведет 10
    
    let mut y = 5;
    y = 10; // Это изменение той же переменной
    println!("{}", y); // Выведет 10
}
```

*Совет на полях: Shadowing позволяет даже изменить тип переменной.Что это такое мы поговорим в следующий главе*

## Психология mut

Почему Rust заставляет нас писать `mut` явно? 

Когда вы видите в коде `let mut counter = 0`, вы сразу понимаете: «Ага, эта переменная будет изменяться». Это своего рода документация, встроенная в синтаксис.

В других языках вы можете увидеть:
```javascript
let counter = 0; // JavaScript
```

И не знать, изменится ли `counter` в дальнейшем, пока не прочитаете весь код.

## Распространенная ловушка

Новички часто пишут такой код:
Попробуйте скопировать в *main.rs* и запустить 

```rust
fn main() {
    let mut x = 5;
    // ... 50 строк кода ...
    // x больше нигде не изменяется
}
```

Компилятор Rust предупредит: «Зачем `mut`, если переменная не изменяется?» Это помогает поддерживать код в чистоте.

**Золотое правило:** В Rust изменяемость — это сознательный выбор, а не случайность. Каждый `mut` — это ваше обещание компилятору и будущим читателям кода: «Да, эта переменная действительно должна изменяться».

*Следующая остановка в нашем путешествии: Shadowing ,мы уже даже немного говорили о нем,Приготовьтесь — там нас ждут еще более интересные открытия!*