# Статические переменные: когда данные живут вечно

Представьте, что вы управляете небольшим кафе. У вас есть касса, столики, меню — всё это появляется утром, когда вы открываетесь, и исчезает вечером, когда закрываетесь. Но есть одна вещь, которая остаётся навсегда: номер вашего кафе на доме. Он был там до вас, он останется после вас.

В Rust такие "вечные" данные создаются с помощью ключевого слова `static`.

## Первая встреча со static

```rust
static CAFE_NUMBER: i32 = 42;

fn main() {
    println!("Наше кафе под номером: {}", CAFE_NUMBER);
}
```

*"Стоп, а чем это отличается от const?"* — спросит внутренний голос. Отличный вопрос! Пока что синтаксис выглядит похоже, но `static` — это совсем другая история.

### Анатомия статической переменной

Давайте разберём синтаксис по частям:

```rust
static ИМЯ_ПЕРЕМЕННОЙ: Тип = значение;
```

- **`static`** — ключевое слово, объявляющее статическую переменную
- **`ИМЯ_ПЕРЕМЕННОЙ`** — имя в SCREAMING_SNAKE_CASE (это соглашение)
- **`: Тип`** — обязательное указание типа,что это вы узнаете позже, сейчас
просто копируйте с примеров
- **`= значение`** — инициализация (должна быть известна на этапе компиляции)

> **На полях:** Почему SCREAMING_SNAKE_CASE? Это визуальный сигнал: "Осторожно, здесь что-то глобальное и постоянное!"

## Статические переменные живут своей жизнью

```rust
static MESSAGE: &str = "Привет из статической памяти!";
static COUNTER: i32 = 0;

fn show_message() {
    println!("{}", MESSAGE);
}

fn main() {
    show_message();
    println!("Счётчик: {}", COUNTER);
}
```

Заметьте: мы обращаемся к `MESSAGE` и `COUNTER` из любого места в программе. Они не принадлежат никому конкретно — они принадлежат всей программе.


## Практические примеры

### Конфигурация приложения
```rust
static APP_NAME: &str = "Мой Супер Калькулятор";
static VERSION: &str = "1.0.0";

fn show_info() {
    println!("{} версия {}", APP_NAME, VERSION);
}
```

### Математические константы
```rust
static PI: f64 = 3.14159265359;
static E: f64 = 2.71828182846;

fn area_of_circle(radius: f64) -> f64 {
    PI * radius * radius
}
```

### Массивы и строки
```rust
static WEEKDAYS: [&str; 7] = [
    "Понедельник", "Вторник", "Среда", "Четверг",
    "Пятница", "Суббота", "Воскресенье"
];

fn get_weekday(index: usize) -> &'static str {
    if index < WEEKDAYS.len() {
        WEEKDAYS[index]
    } else {
        "Неизвестный день"
    }
}
```

## Ограничения и особенности

### Инициализация только константными значениями
```rust
// ✅ Это работает
static COUNT: i32 = 10 + 5;

// ❌ Это НЕ работает
// static RANDOM: i32 = rand::random();  // Функция не константна!
```

### Время жизни 'static
```rust
static GREETING: &str = "Добро пожаловать!";

fn get_greeting() -> &'static str {
    GREETING  // Возвращаем ссылку, которая живёт всю программу
}
```

*"Интересно, а почему это называется 'static lifetime?"* — размышляете вы. Потому что эти данные существуют от начала и до конца программы — статично, неизменно во времени.

## Маленький эксперимент

Попробуйте предсказать, что выведет этот код:

```rust
static mut VISITS: i32 = 0;

fn visit_page() {
    unsafe {
        VISITS += 1;
        println!("Посещение номер: {}", VISITS);
    }
}

fn main() {
    visit_page();
    visit_page();
    visit_page();
}
```

> **Ответ:** Каждый вызов `visit_page()` увеличивает счётчик, потому что `VISITS` — это одна и та же переменная в памяти, а не новая копия при каждом вызове функции.

## Когда использовать static?

**Используйте `static` когда:**
- Нужны глобальные константы (конфигурация, математические константы)
- Данные должны жить всю программу
- Хотите избежать повторных вычислений дорогих константных значений

**Избегайте `static mut` без крайней необходимости** — это источник багов в многопоточных программах.